---
title: 内核近期改变
date: 2020-11-15 19:09:13
tags: kernel
categories:
- kernel
---

# 内核近期改变

* [内核近期改变](#内核近期改变)
    * [ioctl](#ioctl)
        * [1.原始版本的ioctl](#1原始版本的ioctl)
        * [2.内核改进后的ioctl](#2内核改进后的ioctl)
        * [3.在编写过程中的处理办法](#3在编写过程中的处理办法)
        * [4. 原因分析](#4-原因分析)
    * [异步I/O read_iter](#异步io-read_iter)
        * [1.具体变化](#1具体变化)
        * [2.原因分析](#2原因分析)
        * [3.问题](#3问题)
    * [timer计时器发生改变](#timer计时器发生改变)
    * [block 驱动在5.0后进行了非常大的变化](#block-驱动在50后进行了非常大的变化)
        * [原因](#原因)
        * [blk-mq 设计了两层队列](#blk-mq-设计了两层队列)
        * [在架构层面](#在架构层面)
        * [具体到函数](#具体到函数)
    * [内核计时接口发生变化](#内核计时接口发生变化)
    * [系统调用初始化接口变化（未解决）](#系统调用初始化接口变化未解决)
    * [文件系统减少定义数量 （未解决）](#文件系统减少定义数量-未解决)
    * [jprobe 被取消](#jprobe-被取消)

<!-- more -->
## ioctl
### 1.原始版本的ioctl
```
int (*ioctl)(struct inode *, struct file *, unsigned int, unsigned long);
```

### 2.内核改进后的ioctl
```
long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);

long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
```

### 3.在编写过程中的处理办法
* 将原先的写的 ioctl 函数声明给改成下面的 unlocked_ioctl 或者 compat_ioctl,

* 在 file_operations 结构体的初始化中也是一样. 修改为unlocked_ioctl 或者 compat_ioctl,

* 注意参数的兼容性问题, 新的ioctl() 接口没有 struct inode* 参数, 如果ioctl 接口中使用了 inode, 因此需要通过其他方式获取 inode

```
#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
static int XXX_ioctl(
        struct inode *indoe,
        struct file *filp,
        unsigned int cmd,
        unsigned long arg)
{
#else
//long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
//long (*compat_ioctl) (struct file *, unsigned int cmd, unsigned long arg)
static long XXX_unlocked_ioctl(
        struct file *filp,
        unsigned int cmd,
        unsigned long arg)
{
    //struct inode *inode = filp->f_dentry->d_inode;
    //struct inode *inode = filp->d_inode;
    struct inode *inode = inode = file_inode(filp);
#endif
    /*  此处是ioctl() 函数结构的具体实现  */
}
```

同理，file_operations中也进行同样修改。

```
static struct file_operations fpga_fops = {
    .owner  = THIS_MODULE,
    .open   = fpga_open,
    .read   = fpga_read,
    .write = fpga_write,
    .llseek = fpga_llseek,
#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36)
    .ioctl = XXX_ioctl,
#else
    .unlocked_ioctl = XXX_unlocked_ioctl,
#endif
};
```


### 4. 原因分析
`file_operations (include/linux/fs.h)` 结构变化,ioctl本身并不安全，且之前的ioctl使用了大内核锁延迟太大，因此进行修改。具体内容见 
[The new way of ioctl()](https://lwn.net/Articles/119652/)

## 异步I/O read_iter

### 1.具体变化
`file_operations (include/linux/fs.h)` 结构变化，导致

`read_iter` 和 `write_iter` 负责设备驱动的异步读写，取代了之前的 `aio_read` 和 `aio_write`,只需要将资料中二者进行转换即可。

### 2.原因分析
[The iov_iter interface](https://lwn.net/Articles/625077/)

iov_iter 功能增强了，并且试图合并 read(write)_iter 和 splice_read(write)，不过截至2020年5月13日来看这俩似乎还存在着

### 3.问题
`fs/ramfs/file-mmu.c` 中为什么 `file_operations` 里面没有定义 read 和 write， 而只有异步I/O。


## timer计时器发生改变
[Improving the kernel timers API](https://lwn.net/Articles/735887/)
用 `timer_setup` 替换了 `init_timer`,替换内核版本为4.14(2017)，属于较新的替换

```
#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
    init_timer(&dev->getIntrTimer);
    dev->getIntrTimer.data = (unsigned long) dev;
    dev->getIntrTimer.function = GetIntrTimerCallback;
    /* ... */
    add_timer(&dev->getIntrTimer);
#else
    timer_setup(&dev->getIntrTimer, GetIntrTimerCallback, 0);
    /* the third argument may include TIMER_* flags */
    /* ... */
#endif
```

callback function的变化 **参数类型发生变化，否则会编译失败**

```
#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
void GetIntrTimerCallback(unsigned long devAddr)
{
    myDevice *dev = (myDevice *) devAddr;
#else
void GetIntrTimerCallback(struct timer_list *t)
{
    myDevice *dev = from_timer(dev, t, getIntrTimer);
#endif
    /* Do something with "dev" */
```

## block 驱动在5.0后进行了非常大的变化
[In kernel V5 blk_fetch_request() and blk_init_queue() gone. Now What?](https://www.linuxquestions.org/questions/linux-kernel-70/in-kernel-v5-blk_fetch_request-and-blk_init_queue-gone-now-what-4175670215/)  

[Linux Kernel 5.0 – we write Simple Block Device under blk-mq](https://prog.world/linux-kernel-5-0-we-write-simple-block-device-under-blk-mq/)  


[block: remove __bio_kmap_atomic](https://patchwork.kernel.org/patch/10048915/)

**内核工匠 公众号 Multiqueue架构分析**

block 驱动在5.0后进行了非常大的变化

### 原因
是使用了 multi-queue block layer 即 blk-mq 完全取代了之前的 blk-sq（single-queue），
因为从前的IO速度瓶颈在硬件方面，因此可以使用单一队列，即使多个cpu竞争自旋锁获取队列写入权限依旧不过分影响性能。
而最近的高IOPS（io per second）硬件逐渐增多比如ssd，nvme等硬件设备开始大量使用，那么从前的single queue在高IOPS场景下80% cpu时间耗费在锁获取上了，因此设计了新的blk-mq 获取锁仅占用 3% cpu时间。

### blk-mq 设计了两层队列

1. 首先为每个cpu分配了一个软件暂存队列（software staging queue），负责完成bio 提交/完成处理，IO请求暂存（合并、排序等）、IO请求标记、调度、记账（和新的IO调度算法BFS有关）

2. 硬件派发队列（Hardware Dispatch Queue） 为每个硬件队列分派一个硬件派发队列，负责存放软件队列向硬件派发的IO请求，一个和多个软件队列和一个硬件队列存在固定映射关系

### 在架构层面
mq 将 request 和 tag 绑定，request内存分配在块设备驱动初始化时完成（调用blk_mq_alloc_tag_set）避免IO时分配request内存带来消耗

tag作为request（static_rqs/rqs）的索引。

### 具体到函数
有 `blk_fetch_request` , `__blk_end_request_cur`  ,`blk_init_queue`, `__bio_kmap_atomic(bio, iter)` , `__bio_kunmap_atomic(buffer)` 等




其中 取代 `__bio_kmap_atomic(bio, iter)` , `__bio_kunmap_atomic(buffer)` 如下

```
-		char *buffer = __bio_kmap_atomic(bio, iter);
+		char *buffer = kmap_atomic(bvec.bv_page) + bvec.bv_offset;
 		unsigned len = bvec.bv_len >> SECTOR_SHIFT;
 
 		simdisk_transfer(dev, sector, len, buffer,
 				bio_data_dir(bio) == WRITE);
 		sector += len;
-		__bio_kunmap_atomic(buffer);
+		kunmap_atomic(buffer)
```

除此之外 `BLK_MQ_F_SG_MERGE` 和 `QUEUE_FLAG_NO_SG_MERGE`  都可以被省略了
[block: kill BLK_MQ_F_SG_MERGE](https://lore.kernel.org/patchwork/patch/1042759/)

```
-	lo->tag_set.flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE;
+	lo->tag_set.flags = BLK_MQ_F_SHOULD_MERGE;
```

## 内核计时接口发生变化

64位系统中,由于[2038问题](https://en.wikipedia.org/wiki/Year_2038_problem) 时间戳 timespec 在 inode数据结构中的i_*time 中弃用，转而使用 timespec64

相应的 getnstimeofday 等函数也被弃用， 转而使用 `ktime_get_ts64(struct timespec64 *ts)` 等函数获取时间，另外需要注意 这个函数必须使用 GPL协议才能成功加载。

详见内核时间api文件，
[ktime accessors](https://www.kernel.org/doc/html/latest/core-api/timekeeping.html)

最新设计的时间数据结构为 `ktime_t` 获取方式为 `ktime_t ktime_get(void)`


## 系统调用初始化接口变化（未解决）

系统调用初始化接口代码越变越少，而且有点难以理解，除了在`arch/x86/entry/syscall` 目录下定义之外，还用了同目录下的脚本直接生成了ni代码

具体的解决办法是直接ftrace跟踪一波，看看syscall最新的调用路径


## 文件系统减少定义数量 （未解决）

文件系统减少了大量file_operations定义数量，例如 aio_read  aio_write 等异步代码直接被省略掉，read 和 write 接口基本也不定义了， 似乎使用了 read_iter 和 write_iter 替代了前两类接口

具体原因还没搞清楚，但是在 [[V5,17/30] fs: use read_iter and write_iter rather than aio_read and aio_write](https://lore.kernel.org/patchwork/patch/350494/) 中显示 aio被明确删除掉，用iter替代。

此外 `file_operations` 当中的 readdir 等接口也被取消，直接由read/read_iter和 iterate 替代,iterate基本上可以理解为负责执行ls命令， filldentry_t 由 dir_context 替代。


## jprobe 被取消

在 kprobe中只剩下kprobe和kretprobe，jprobe及相关的一套函数被取消，替代方式如下：

`/source/samples/kprobes/kprobe_example.c` 和 `/source/samples/kprobes/kretprobe_example.c` 中示例


使用kprobe中的handler_pre和handler_post替代。
