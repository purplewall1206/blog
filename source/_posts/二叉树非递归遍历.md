---
title: 二叉树非递归遍历
date: 2020-11-24 10:28:59
tags: [leetcode, algorithm, binarytree]
---

二叉树非递归遍历总是容易忘，这次从原理出发理解一次。

```
    1
   / \
  2   3
 / \ /
4  5 6
```
<!-- more -->
# preorder
```
    handle(p->val);
    preorder(root->left);
    preorder(root->right);
```

1->2->4->5->3->6 

先序输出顺序是中左右，因此首先输出，其次要保存左子树，穷尽左子树之后弹出节点，最后输出右子树

```
    stack<TreeNode*> st;
    TreeNode* p = root;
    while (p != NULL || !st.empty()）{
        while (p != NULL) {
            handle(p->val);
            st.push(p);
            p = p->left;
        }
        if (!st.empty()) {
            p = st.top();
            st.pop();
            p = p->right;
        }
    }
```


# inorder
```
    inorder(p->left);
    handle(p->val);
    inorder(p->right);
```

4->2->5->1->6->3

中序遍历的输出顺序是左中右，和先序遍历有相似性，因为也需要先保存左子树，再弹出左子树找到中和右。

```
    stack<TreeNode*> st;
    TreeNode* p = root;
    while (p != NULL || !st.empty()) {
        st.push(p);
        p = p->left;
    }
    if (!st.empty()) {
        p = st.top();
        st.pop();
        handle(p->val);
        p = p->right;
    }
```

# postorder
```
    postorder(p->left);
    postorder(p->right);
    handle(p->val);
```

4->5->2->6->3->1

后序遍历输出顺序是左右中，先保存左侧节点，然后检查右侧节点，当右子树为空或者已经被访问了，可以访问这个节点

```
    stack<TreeNode*> st;
    TreeNode* p = root;
    while (p != NULL || !st.empty()) {
        while (p != NULL) {
            st.push(p);
            p = p->left;
        }
        p = s.top();
        TreeNode* tmp = NULL;
        while (!st.empty() && (p->right == NULL || p->right == tmp)) {
            st.pop();
            if (!st.empty()) {
                tmp = p;
                p = st.top();
            }
        }
        if (st.emtpy()) break;
        p = p->right;
    }
```

# BFS

1->2->3->4->5->6

广度优先按照层次每次保存一层，当输出的时候记录当前队列长度，该长度即为上层被保存的节点数量，依次遍历即为按层次输出

```
    queue<TreeNode*> q;
    TreeNode* p = NULL;
    q.push(p);
    while (!q.emtpy()) {
        int size = q.size();
        for (int i = 0;i < size;i++) {
            p = q.front();
            q.pop();

            handle(p->val);

            if (p->left != NULL) q.push(p->left);
            if (p->right != NULL) q.push(p->right);
        }
        
    }
```