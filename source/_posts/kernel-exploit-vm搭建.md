---
title: kernel-exploit-vm搭建
date: 2020-11-28 15:15:29
tags: [kernel, vm, exploit]
---

* 环境：Manjaro(archlinux)18   Linux wangzc-pc 4.14.193-1-MANJARO  x86_64 GNU/Linux

<!-- more -->

## 1. 内核编译
### 1.1 linux-3.7.1

* 使用gcc-4.9编译

    由于 kernel 3.x 开发时间较早，因此不适用PIC PIE等加载机制，尤其在gcc-10环境下已经变成默认设置。

    因此我们最好使用 **gcc-4.9** 进行编译，可以使用 aur 库中的自动安装（编译时间较长），安装之后修改 kernel3.x 的 Makefile。

    ```
    # 安装gcc-4.9
    yay -S gcc49

    # 修改 Makefile
    CC           = $(CROSS_COMPILE)gcc  ->   gcc-4.9

    HOSTCC       = gcc                  ->   gcc-4.9
    ```

* 编译选项

    Kernel hacking ---> Compile the kernel with debug info 

    Kernel hacking ---> Compile the kernel with frame pointer

    Kernel hacking ---> KGDB: kernel debugger

* perl 脚本修改

    `kernel/timeconst.pl` 脚本中出现 `if (!define(@val))` 无法执行的问题，解决办法是修改为 `if (!@val)` 即可

* 设置默认配置
    ```
    make x86_64_defconfig
    ```
    `make -j4` 进行编译，在 `arch/x86_64/boot` 目录下，生成bzImage


### 1.2 linux-4.4.232

* 设置默认配置

    ```
    make x86_64_defconfig
    make kvmconfig
    ```

* 修改编译选项

    Kernel hacking → Compile-time checks and compiler options  
        
        -> Compile the kernel with debug info 
        -> Compile the kernel with frame pointers

    Kernel hacking → KGDB: kernel debugger



### 1.3 linux-5.8.2
* 设置默认配置

    ```
    make x86_64_defconfig
    make kvm_guest.config
    # 'make kvmconfig' will be removed after Linux 5.10
    ```
* 修改编译选项

    Kernel hacking > Compile-time checks and compiler options

    Kernel hacking > Kernel debugging

## 2. 编译busybox-1.32.0

* 编译选项 

    选中 setting > Build static binary (no shared libs)  

    取消 inetd

    `make install -j2`

* 打包

    编译成功后进入 `_install` 目录，创建

    ```
    mkdir proc sys dev etc etc/init.d
    vim etc/init.d/rcS

    # 写入
    mkdir /home
    mkdir /home/ppw
    touch /etc/passwd
    touch /etc/group
    adduser ppw
    cat /proc/kallsyms | grep start_kernelmkdir /home
    mkdir /home/ppw
    touch /etc/passwd
    touch /etc/group
    adduser ppw
    cat /proc/kallsyms | grep start_kernel

    find . | cpio -o --format=newc > rootfs.cpio
    ```

## 3. qemu 启动，调试

```
#!/bin/sh
# linux-5.8.2/arch/x86_64/boot/bzImage
# linux-4.4.232/arch/x86_64/boot/bzImage
# linux-3.7.1/arch/x86_64/boot/bzImage
qemu-system-x86_64 -kernel linux-3.7.1/arch/x86_64/boot/bzImage \
-initrd busybox-1.32.0/_install/rootfs.img                \
-append "nokalsr  console=ttyS0  root=/dev/ram rdinit=/sbin/init"   \
-cpu kvm64,+smep                                          \
--nographic -gdb tcp::1234                                \

```


共享目录还没有进行测试。2.6内核测试不成功，不知道为啥。
```
qemu-system-i386 -kernel bzImage 
-s 
-append nokaslr 
-initrd initramfs.img 
-fsdev local,security_model=passthrough,id=fsdev-fs0,path=/home/error404/Desktop/CTF_question/Kernel/Buffer_overflow_basic_1/Share 
-device virtio-9p-pci,id=fs0,fsdev=fsdev-fs0,mount_tag=rootme
```

解决方法
```
mkdir rootfs
# 解压缩
cpio -idvm < ../rootfs.cpio
# 压缩
find . | cpio -o --format=newc > rootfs.cpio
```


另一个例子
```
mount -t proc proc /proc
mount -t sysfs sysfs /sys
mount -t devtmpfs none /dev
/sbin/mdev -s
mkdir -p /dev/pts
mount -vt devpts -o gid=4,mode=620 none /dev/pts
chmod 666 /dev/ptmx
cat /proc/kallsyms > /tmp/kallsyms
echo 1 > /proc/sys/kernel/kptr_restrict
echo 1 > /proc/sys/kernel/dmesg_restrict
ifconfig eth0 up
udhcpc -i eth0
ifconfig eth0 10.0.2.15 netmask 255.255.255.0
route add default gw 10.0.2.2 
insmod /core.ko
 
poweroff -d 1200000 -f &
setsid /bin/cttyhack setuidgid 0 /bin/sh
echo 'sh end!\n'
umount /proc
umount /sys
 
poweroff -d 0  -f
```


* 变量kptr_restrict是可以用来限制内核地址的打印，当kptr_restrict=0时，会直接打印内核地址（%p和%pK效果一样）；
* 当kptr_restrict=1时，若在中断上下文或软中断时，%pK打印“pK-error”，否则内核地址打印全0；
* 当kptr_restrict=2时，%pK打印内核地址为全0；


dmesg能够输出kernel ring buffer中的内容，这些内容中可能会包含一些敏感信息，我们可以通过设置内核参数 dmesg_restrict 为 1 的方式来禁止普通用户查看demsg信息。


* mmap_min_addr
    
    指定用户进程通过mmap可使用的最小虚拟内存地址，以避免其在低地址空间产生映射导致安全问题。

* kptr_restrict / dmesg_restrict
    
    在linux内核漏洞利用中常常使用commit_creds和prepare_kernel_cred来完成提权，它们的地址可以从/proc/kallsyms中读取。/proc/sys/kernel/kptr_restrict被默认设置为1以阻止通过这种方式泄露内核地址。dmesg_restrict限制非特权读dmesg（Restrict unprivileged access to kernel syslog）

* SMEP/SMAP
    SMEP(Supervisor Mode Execution Prevention，管理模式执行保护)和SMAP(Supervisor Mode Access Prevention，管理模式访问保护)，其作用分别是禁止内核执行用户空间的代码和禁止内核访问用户空间的数据。